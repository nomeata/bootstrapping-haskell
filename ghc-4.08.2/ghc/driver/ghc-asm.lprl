%************************************************************************
%*									*
\section[Driver-asm-fiddling]{Fiddling with assembler files}
%*									*
%************************************************************************

Tasks:
\begin{itemize}
\item
Utterly stomp out C functions' prologues and epilogues; i.e., the
stuff to do with the C stack.
\item
Any other required tidying up.
\end{itemize}

General note [chak]: Many regexps are very fragile because they rely on white
space being in the right place.  This caused trouble with gcc 2.95 (at least
on Linux), where the use of white space in .s files generated by gcc suddenly 
changed.  To guarantee compatibility across different versions of gcc, make
sure (at least on i386-.*-linux) that regexps tolerate varying amounts of white
space between an assembler statement and its arguments as well as after a the
comma separating multiple arguments.  

\emph{For the time being, I have corrected the regexps for i386-.*-linux.  I
didn't touch all the regexps for other i386 platforms, as I don't have
a box to test these changes.}

HPPA specific notes:
\begin{itemize}
\item
The HP linker is very picky about symbols being in the appropriate
space (code vs. data).  When we mangle the threaded code to put the
info tables just prior to the code, they wind up in code space
rather than data space.  This means that references to *_info from
un-mangled parts of the RTS (e.g. unthreaded GC code) get
unresolved symbols.  Solution:  mini-mangler for .c files on HP.  I
think this should really be triggered in the driver by a new -rts
option, so that user code doesn't get mangled inappropriately.
\item
With reversed tables, jumps are to the _info label rather than to
the _entry label.  The _info label is just an address in code
space, rather than an entry point with the descriptive blob we
talked about yesterday.  As a result, you can't use the call-style
JMP_ macro.  However, some JMP_ macros take _info labels as targets
and some take code entry points within the RTS.  The latter won't
work with the goto-style JMP_ macro.  Sigh.  Solution: Use the goto
style JMP_ macro, and mangle some more assembly, changing all
"RP'literal" and "LP'literal" references to "R'literal" and
"L'literal," so that you get the real address of the code, rather
than the descriptive blob.  Also change all ".word P%literal"
entries in info tables and vector tables to just ".word literal,"
for the same reason.  Advantage: No more ridiculous call sequences.
\end{itemize}

%************************************************************************
%*									*
\subsection{Constants for various architectures}
%*									*
%************************************************************************

\begin{code}
sub init_TARGET_STUFF {

    #--------------------------------------------------------#
    if ( $TargetPlatform =~ /^alpha-.*-.*/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DONT THINK THIS APPLIES'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\$C(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align\s+\d+|\.(globl|ent)\s+\S+|\#.*|\.(file|loc)\s+\S+\s+\S+|\.text|\.r?data)\n)';
    $T_COPY_DIRVS   = '^\s*(\#|\.(file|globl|ent|loc))';

    $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';
    $T_DOT_WORD	    = '\.quad';
    $T_DOT_GLOBAL   = '^\t\.globl';
    $T_HDR_literal  = "\.rdata\n\t\.align 3\n";
    $T_HDR_misc	    = "\.text\n\t\.align 3\n";
    $T_HDR_data	    = "\.data\n\t\.align 3\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 3\n";
    $T_HDR_srt      = "\.text\n\t\.align 3\n";
    $T_HDR_info	    = "\.text\n\t\.align 3\n";
    $T_HDR_entry    = "\.text\n\t\.align 3\n";
    $T_HDR_fast	    = "\.text\n\t\.align 3\n";
    $T_HDR_vector   = "\.text\n\t\.align 3\n";
    $T_HDR_direct   = "\.text\n\t\.align 3\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^hppa/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DONT THINK THIS APPLIES'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^L\$C(\d+)$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = '';

    $T_MOVE_DIRVS   = '^((\s+\.(IMPORT|EXPORT|PARAM).*|\s+\.align\s+\d+|\s+\.(SPACE|SUBSPA)\s+\S+|\s*)\n)';
    $T_COPY_DIRVS   = '^\s+\.(IMPORT|EXPORT)';

    $T_hsc_cc_PAT   = '\.STRING.*\)(hsc|cc) (.*)\\\\x09(.*)\\\\x00"';
    $T_DOT_WORD	    = '\.(blockz|word|half|byte)';
    $T_DOT_GLOBAL   = '^\s+\.EXPORT';
    $T_HDR_literal  = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$LIT\$\n";
    $T_HDR_misc	    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_data	    = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_consist  = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$LIT\$\n";
    $T_HDR_closure  = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_srt      = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_info	    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_entry    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_fast	    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_vector   = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_direct   = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^i386-.*-(linuxaout|freebsd2|netbsd|openbsd|nextstep3|cygwin32|mingw32)$/ ) {
				# NeXT added but not tested. CaS

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';
    $T_X86_PRE_LLBL_PAT = 'L';
    $T_X86_PRE_LLBL	    = 'L';
    $T_X86_BADJMP   = '^\tjmp [^L\*]';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s+\d+(,0x90)?|\.globl\s+\S+|\.text|\.data|\.stab[^n].*|\.type\s+.*|\.size\s+.*)\n)';
    $T_COPY_DIRVS   = '\.(globl|stab)';
    $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';
    $T_DOT_WORD	    = '\.(long|word|value|byte|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.text\n\t\.align 2\n";
    $T_HDR_misc	    = "\.text\n\t\.align 2,0x90\n";
    $T_HDR_data	    = "\.data\n\t\.align 2\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 2\n";
    $T_HDR_closure  = "\.data\n\t\.align 2\n\t.long 0\n" if ( $TargetPlatform =~ /.*-mingw32$/ );
    $T_HDR_srt      = "\.text\n\t\.align 2\n";
    $T_HDR_info	    = "\.text\n\t\.align 2\n"; # NB: requires padding
    $T_HDR_entry    = "\.text\n"; # no .align so we're right next to _info (arguably wrong...?)
    $T_HDR_fast	    = "\.text\n\t\.align 2,0x90\n";
    $T_HDR_vector   = "\.text\n\t\.align 2\n"; # NB: requires padding
    $T_HDR_direct   = "\.text\n\t\.align 2,0x90\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^i386-.*-(solaris2|linux|freebsd|netbsd_elf)$/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = # regexp that says what comes before APP/NO_APP
		      ($TargetPlatform =~ /-(linux|freebsd|netbsd_elf)$/) ? '#' : '/' ;
    $T_CONST_LBL    = '^\.LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';
    $T_X86_PRE_LLBL_PAT = '\.L';
    $T_X86_PRE_LLBL	    = '.L';
    $T_X86_BADJMP   = '^\tjmp\s+[^\.\*]';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s+\d+(,\s*0x90)?|\.globl\s+\S+|\.text|\.data|\.section\s+.*|\.type\s+.*|\.Lfe.*\n\s*\.size\s+.*|\.size\s+.*|\.ident.*)\n)';
    $T_COPY_DIRVS   = '\.(globl)';

    if ( $TargetPlatform =~ /freebsd|netbsd_elf/ ) {
        $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';
    } else {
        $T_hsc_cc_PAT   = '\.string.*\)(hsc|cc) (.*)\\\\t(.*)"';
    }

    $T_DOT_WORD	    = '\.(long|value|byte|zero)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.section\t\.rodata\n"; # or just use .text??? (WDP 95/11)
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 4\n"; # ToDo: change align??
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n"; # ToDo: change align?
    $T_HDR_srt      = "\.text\n\t\.align 4\n"; # ToDo: change align?
    $T_HDR_info	    = "\.text\n\t\.align 4\n"; # NB: requires padding
    $T_HDR_entry    = "\.text\n"; # no .align so we're right next to _info (arguably wrong...?)
    $T_HDR_fast	    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n"; # NB: requires padding
    $T_HDR_direct   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^m68k-.*-sunos4/ ) {

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^# MAY NOT APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align\s+\d+|\.proc\s+\d+|\.const|\.cstring|\.globl\s+\S+|\.text|\.data|\.even|\.stab[^n].*)\n)';
    $T_COPY_DIRVS   = '\.(globl|proc|stab)';
    $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';

    $T_DOT_WORD	    = '\.long';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.text\n\t\.even\n";
    $T_HDR_misc	    = "\.text\n\t\.even\n";
    $T_HDR_data	    = "\.data\n\t\.even\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.even\n";
    $T_HDR_srt      = "\.text\n\t\.even\n";
    $T_HDR_info	    = "\.text\n\t\.even\n";
    $T_HDR_entry    = "\.text\n\t\.even\n";
    $T_HDR_fast	    = "\.text\n\t\.even\n";
    $T_HDR_vector   = "\.text\n\t\.even\n";
    $T_HDR_direct   = "\.text\n\t\.even\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^mips-.*/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^\s*#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\$LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align\s+\d+|\.(globl|ent)\s+\S+|\.text|\.r?data)\n)';
    $T_COPY_DIRVS   = '\.(globl|ent)';

    $T_hsc_cc_PAT   = 'I WAS TOO LAZY TO DO THIS BIT (WDP 95/05)';
    $T_DOT_WORD	    = '\.word';
    $T_DOT_GLOBAL   = '^\t\.globl';
    $T_HDR_literal  = "\t\.rdata\n\t\.align 2\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_consist  = 'TOO LAZY TO DO THIS TOO';
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_srt      = "\t\.text\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_fast	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";
    $T_HDR_direct   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^powerpc-.*|^rs6000-.*/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'NOT APPLICABLE'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = 'NOT APPLICABLE'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.toc|\.align \d+|\.csect \S+|\t\.?l?globl \S+)\n)';
    $T_COPY_DIRVS   = '\.(l?globl)';

    $T_hsc_cc_PAT   = '\.byte.*\)(hsc|cc) (.*)"\n\t\.byte \d+\n\t\.byte "(.*)"\n\t\.byte \d+';
    $T_DOT_WORD	    = '\.long';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_toc      = "\.toc\n";
    $T_HDR_literal  = "\.csect .data[RW]\n\t\.align 2\n";		#not RO!?
    $T_HDR_misc	    = "# misc\n\.csect \.text[PR]\n\t\.align 2\n";
    $T_HDR_data	    = "# data\n\.csect \.data[RW]\n\t\.align 2\n";
    $T_HDR_consist  = "# consist\n\.csect \.data[RW]\n\t\.align 2\n";
    $T_HDR_closure  = "# closure\n\.csect \.data[RW]\n\t\.align 2\n";
    $T_HDR_srt      = "# closure\n\.csect \.data[RW]\n\t\.align 2\n";
    $T_HDR_info	    = "# info\n\.csect \.data[RW]\n\t\.align 2\n"; #not RO!?
    $T_HDR_entry    = "# entry\n\.csect \.text[PR]\n\t\.align 2\n";
    $T_HDR_fast	    = "# fast\n\.csect \.text[PR]\n\t\.align 2\n";
    $T_HDR_vector   = "# vector\n\.csect \.data[RW]\n\t\.align 2\n"; #not RO!?
    $T_HDR_direct   = "# direct\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^sparc-.*-solaris2/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DOES NOT SEEM TO APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\.LLC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^((\s+\.align\s+\d+|\s+\.proc\s+\d+|\s+\.global\s+\S+|\.text|\.data|\.stab.*|\.section.*|\s+\.type.*|\s+\.size.*)\n)';
    $T_COPY_DIRVS   = '\.(global|proc|stab)';

    $T_hsc_cc_PAT   = '\.asciz.*\)(hsc|cc) (.*)\\\\t(.*)"';
    $T_DOT_WORD	    = '\.(word|byte|half|skip|uahalf|uaword)';
    $T_DOT_GLOBAL   = '^\t\.global';
    $T_HDR_literal  = "\.text\n\t\.align 8\n";
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 8\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_srt      = "\.data\n\t\.align 4\n";
    $T_HDR_info	    = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n\t\.align 4\n";
    $T_HDR_fast	    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n";
    $T_HDR_direct   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^sparc-.*-sunos4/ ) {

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^# DOES NOT SEEM TO APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^((\s+\.align\s+\d+|\s+\.proc\s+\d+|\s+\.global\s+\S+|\.text|\.data|\.stab.*)\n)';
    $T_COPY_DIRVS   = '\.(global|proc|stab)';
    $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';

    $T_DOT_WORD	    = '\.word';
    $T_DOT_GLOBAL   = '^\t\.global';
    $T_HDR_literal  = "\.text\n\t\.align 8\n";
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 8\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_srt      = "\.data\n\t\.align 4\n";
    $T_HDR_info	    = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n\t\.align 4\n";
    $T_HDR_fast	    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n";
    $T_HDR_direct   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } else {
	print STDERR "$Pgm: don't know how to mangle assembly language for: $TargetPlatform\n";
	exit 1;
    }

if ( 0 ) {
print STDERR "T_STABBY: $T_STABBY\n";
print STDERR "T_US: $T_US\n";
print STDERR "T_PRE_APP: $T_PRE_APP\n";
print STDERR "T_CONST_LBL: $T_CONST_LBL\n";
print STDERR "T_POST_LBL: $T_POST_LBL\n";
if ( $TargetPlatform =~ /^i386-/ ) {
    print STDERR "T_X86_PRE_LLBL_PAT: $T_X86_PRE_LLBL_PAT\n";
    print STDERR "T_X86_PRE_LLBL: $T_X86_PRE_LLBL\n";
    print STDERR "T_X86_BADJMP: $T_X86_BADJMP\n";
}
print STDERR "T_MOVE_DIRVS: $T_MOVE_DIRVS\n";
print STDERR "T_COPY_DIRVS: $T_COPY_DIRVS\n";
print STDERR "T_hsc_cc_PAT: $T_hsc_cc_PAT\n";
print STDERR "T_DOT_WORD: $T_DOT_WORD\n";
print STDERR "T_HDR_literal: $T_HDR_literal\n";
print STDERR "T_HDR_misc: $T_HDR_misc\n";
print STDERR "T_HDR_data: $T_HDR_data\n";
print STDERR "T_HDR_consist: $T_HDR_consist\n";
print STDERR "T_HDR_closure: $T_HDR_closure\n";
print STDERR "T_HDR_info: $T_HDR_info\n";
print STDERR "T_HDR_entry: $T_HDR_entry\n";
print STDERR "T_HDR_fast: $T_HDR_fast\n";
print STDERR "T_HDR_vector: $T_HDR_vector\n";
print STDERR "T_HDR_direct: $T_HDR_direct\n";
}

}
\end{code}

%************************************************************************
%*									*
\subsection{Mangle away}
%*									*
%************************************************************************

\begin{code}
sub mangle_asm {
    local($in_asmf, $out_asmf) = @_;

    # multi-line regexp matching:
    local($*) = 1;
    local($i, $c);


    &init_TARGET_STUFF();
    &init_FUNNY_THINGS();

    # perl4 on alphas SEGVs when give ${foo} substitutions in patterns.
    # To avoid them we declare some locals that allows to avoid using curlies.
    local($TUS)      = ${T_US};
    local($TPOSTLBL) = ${T_POST_LBL};
    local($TMOVEDIRVS) = ${T_MOVE_DIRVS};
    local($TPREAPP)    = ${T_PRE_APP};
    local($TCOPYDIRVS) = ${T_COPY_DIRVS};
    local($TDOTWORD)   = ${T_DOT_WORD};

    open(INASM, "< $in_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$in_asmf' (to read)\n");
    open(OUTASM,"> $out_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$out_asmf' (to write)\n");

    # read whole file, divide into "chunks":
    #	record some info about what we've found...

    @chk = ();		# contents of the chunk
    $numchks = 0;	# number of them
    @chkcat = ();	# what category of thing in each chunk
    @chksymb = ();	# what symbol(base) is defined in this chunk
    %slowchk = ();	# ditto, its regular "slow" entry code
    %fastchk = ();	# ditto, fast entry code
    %closurechk = ();	# ditto, the (static) closure
    %srtchk = ();	# ditto, its SRT (for top-level things)
    %infochk = (); 	# given a symbol base, say what chunk its info tbl is in
    %vectorchk = ();    # ditto, return vector table
    $EXTERN_DECLS = '';	# .globl <foo> .text (MIPS only)

    $i = 0; $chkcat[0] = 'misc'; $chk[0] = '';

    while (<INASM>) {
	s/^(.*?)\s*$/$1\n/;
	next if $T_STABBY && /^\.stab.*$TUS[@]?__stg_split_marker/o;
	next if $T_STABBY && /^\.stab.*ghc.*c_ID/;
	next if /^\t\.def.*endef$/;
	next if /$TPREAPP(NO_)?APP/o; 
    	next if /^;/ && $TargetPlatform =~ /^hppa/;

	next if /(^$|^\t\.file\t|^ # )/ && $TargetPlatform =~ /^(mips|powerpc|rs6000)-/;

	last if /^_section_\.text:$/ && $TargetPlatform =~ /^powerpc-|^rs6000-/;

	if ( $TargetPlatform =~ /^mips-/ 
	  && /^\t\.(globl \S+ \.text|comm\t)/ ) {
	    $EXTERN_DECLS .= $_ unless /(__DISCARD__|\b(PK_|ASSIGN_)(FLT|DBL)\b)/;
  
	# As a temporary solution for compiling "foreign export" declarations,
	# we use global variables to pass arguments from C to STG land.
	# These declarations live in the .hc file and not in the generated C
	# stub file, so we let them pass through here.
	} elsif ( /^\t\.comm\t__fexp_.*$/ ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^\s+/ ) { # most common case first -- a simple line!
	    # duplicated from the bottom

	    $chk[$i] .= $_;

	} elsif ( /\.\.ng:$/ && $TargetPlatform =~ /^alpha-/ ) {
	    # Alphas: Local labels not to be confused with new chunks
	    $chk[$i] .= $_;
  
	# NB: all the rest start with a non-space

	} elsif ( $TargetPlatform =~ /^mips-/
	       && /^\d+:/ ) { # a funny-looking very-local label
	    $chk[$i] .= $_;

	} elsif ( /$T_CONST_LBL/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'literal';
	    $chksymb[$i] = $1;

	} elsif ( /^$TUS[@]?__stg_split_marker(\d+)$TPOSTLBL[@]?$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'splitmarker';
	    $chksymb[$i] = $1;

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_info$TPOSTLBL[@]?$/o ) {
	    $symb = $1;
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'infotbl';
	    $chksymb[$i] = $symb;

	    die "Info table already? $symb; $i\n" if defined($infochk{$symb});

	    $infochk{$symb} = $i;

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_(entry|ret)$TPOSTLBL[@]?$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'slow';
	    $chksymb[$i] = $1;

	    $slowchk{$1} = $i;

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_fast\d*$TPOSTLBL[@]?$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'fast';
	    $chksymb[$i] = $1;

	    $fastchk{$1} = $i;

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_closure$TPOSTLBL[@]?$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'closure';
	    $chksymb[$i] = $1;

	    $closurechk{$1} = $i;

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_srt$TPOSTLBL[@]?$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'srt';
	    $chksymb[$i] = $1;

	    $srtchk{$1} = $i;

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_ct$TPOSTLBL[@]?$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^$TUS[@]?ghc.*c_ID$TPOSTLBL/o ) {
	    $chk[++$i]  = $_;
	    $chkcat[$i] = 'consist';

	} elsif ( /^($TUS[@]?__gnu_compiled_c|gcc2_compiled\.)$TPOSTLBL/o ) {
	    ; # toss it

	} elsif ( /^$TUS[A-Za-z0-9_]+\.\d+$TPOSTLBL[@]?$/o
	       || /^$TUS[@]?.*_CAT$TPOSTLBL[@]?$/o 		# PROF: _entryname_CAT
	       || /^$TUS[@]?.*_done$TPOSTLBL[@]?$/o		# PROF: _module_done
	       || /^$TUS[@]?_module_registered$TPOSTLBL[@]?$/o	# PROF: _module_registered
	       ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^([A-Za-z0-9_]+)\s+\.comm/ && $TargetPlatform =~ /^hppa/ ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'bss';
  	    $chksymb[$i] = '';

 	} elsif ( $TargetPlatform =~ /^powerpc-|^rs6000-/ && /^LC\.\.([0-9]+)/ ) {
 	    $chk[++$i]   = $_;
 	    $chkcat[$i]  = 'toc';
   	    $chksymb[$i] = $1;

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_cc(s)?$TPOSTLBL[@]?$/o ) {
            # all CC_ symbols go in the data section...
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_(alt|dflt)$TPOSTLBL[@]?$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'misc';
	    $chksymb[$i] = '';
 	    #$symbtmp = $1;
            #$chksymb[$i] = $symbtmp if ($TargetPlatform =~ /^powerpc-|^rs6000-/) ; #rm andre

	} elsif ( /^$TUS[@]?([A-Za-z0-9_]+)_vtbl$TPOSTLBL[@]?$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'vector';
	    $chksymb[$i] = $1;

	    $vectorchk{$1} = $i;

	# As a temporary solution for compiling "foreign export" declarations,
	# we use global variables to pass arguments from C to STG land.
	# These declarations live in the .hc file and not in the generated C
	# stub file, so we let them pass through here.
	} elsif ( /^[\t ]+\.comm[\t ]+__fexp_.*$/ ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( $TargetPlatform =~ /^i386-.*-solaris2/
	     &&   /^(_uname|uname|stat|fstat):/ ) {
	    # for some utterly bizarre reason, this platform
	    # likes to drop little local C routines with these names
	    # into each and every .o file that #includes the
	    # relevant system .h file.  Yuck.  We just don't
	    # tolerate them in .hc files (which we are processing
	    # here).  If you need to call one of these things from
	    # Haskell, make a call to your own C wrapper, then
	    # put that C wrapper (which calls one of these) in a
	    # plain .c file.  WDP 95/12
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'toss';
	    $chksymb[$i] = $1;

	} elsif ( /^$TUS[@]?[A-Za-z0-9_]/o
		&& ( $TargetPlatform !~ /^hppa/ # need to avoid local labels in this case
		   || ! /^L\$\d+$/ )
		&& ( $TargetPlatform !~ /^powerpc|^rs6000/ # ditto
		   || ! /^(L\.\.\d+|LT\.\..*):$/ ) ) {
	    local($thing);
	    chop($thing = $_);
	    print "Funny global thing?: $_"
		unless $KNOWN_FUNNY_THING{$thing}
		    || /^$TUS[@]?stg_.*$TPOSTLBL[@]?$/o    # RTS internals
		    || /^$TUS[@]__fexp_.*$TPOSTLBL$/o	   # foreign export
		    || /^$TUS[@]?__init.*$TPOSTLBL$/o	   # __init<module>
		    || /^$TUS[@]?.*_btm$TPOSTLBL$/o        # large bitmaps
		    || /^$TUS[@]?.*_closure_tbl$TPOSTLBL$/o; # closure tables
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'misc';
            if ($TargetPlatform =~ /^powerpc-|^rs6000-/) 
	       { $chksymb[$i] = $thing; }
	    else { $chksymb[$i] = ''; };

	} else { # simple line (duplicated at the top)

	    $chk[$i] .= $_;
	}
    }
    $numchks = $#chk + 1;

    # the division into chunks is imperfect;
    # we throw some things over the fence into the next
    # chunk.
    #
    # also, there are things we would like to know
    # about the whole module before we start spitting
    # output.

    local($FIRST_MANGLABLE) = ($TargetPlatform =~ /^(alpha-|hppa|mips-)/) ? 1 : 0;

#   print STDERR "first chunk to mangle: $FIRST_MANGLABLE\n";

    # Alphas: NB: we start meddling at chunk 1, not chunk 0
    # The first ".rdata" is quite magical; as of GCC 2.7.x, it
    # spits a ".quad 0" in after the v first ".rdata"; we
    # detect this special case (tossing the ".quad 0")!
    local($magic_rdata_seen) = 0;
  
    # HPPAs, MIPSen: also start medding at chunk 1

    if ($TargetPlatform =~ /^powerpc|^rs6000/) {
       print OUTASM $T_HDR_toc; # yes, we have to put a .toc 
                                # in the beginning of every file!
    %tocequiv = ();          # maps toc symbol number to toc symbol
    %revtocequiv = ();       # maps toc symbol to toc symbol number
    for ($i = 1; $i < $numchks; $i++) {
	$chk[$i] =~ s/\[RW\]//g;
	$chk[$i] =~ s/\[DS\]//g;
	$chk[$i] =~ s/^\.csect .*\[DS\]$//g;

	if ( $chkcat[$i] eq 'toc' && $chk[$i] !~ /\.byte/ )
#ToDo: instead of all these changes, just fix mangle_powerpc_tailjump and delete/ignore these tocs?
	   { $chk[$i] =~ s/$T_MOVE_DIRVS//g;
	     $chk[$i] =~ s/\t\.tc (\S+)\[TC\],(\S+_fast\d+)/\t\.tc \1\[TC\],\.\2/; 
	     $chk[$i] =~ s/\t\.tc (\S+)\[TC\],(\S+_entry)\n/\t\.tc \1\[TC\],\.\2\n/;
	     $chk[$i] =~ s/\t\.tc (\S+)\[TC\],(ret_\S+)/\t\.tc \1\[TC\],\.\2/;
	     $chk[$i] =~ s/\t\.tc (\S+)\[TC\],(alt_\S+)/\t\.tc \1\[TC\],\.\2/;
	     $chk[$i] =~ s/\t\.tc (\S+)\[TC\],(vtbl_\S+)/\t\.tc \1\[TC\],\.\2/;

             $tocnumber = $chksymb[$i];
             $tocsymb = $chk[$i];
             $tocsymb =~ s/^LC\.\.\d+:\n//;
             $tocsymb =~ s/^\t\.tc \S+,(\S+)\n/\1/;
             $tocequiv{$tocnumber} = $tocsymb;

           } elsif ( $chkcat[$i] eq 'toc' && $chk[$i] =~ /\.byte/ ) {
             $chkcat[$i] = 'literal';
           }
    }
    };

    for ($i = $FIRST_MANGLABLE; $i < $numchks; $i++) {
	$c = $chk[$i]; # convenience copy

#	print STDERR "\nCHK $i (BEFORE) (",$chkcat[$i],"):\n", $c;

	# toss all prologue stuff; HPPA is pretty weird
	# (see elsewhere)
	$c = &mash_hppa_prologue($c) if $TargetPlatform =~ /^hppa/;

	# be slightly paranoid to make sure there's
	# nothing surprising in there
	if ( $c =~ /--- BEGIN ---/ ) {
	    if (($p, $r) = split(/--- BEGIN ---/, $c)) {

		if ($TargetPlatform =~ /^i386-/) {
		    $p =~ s/^\tpushl\s+\%edi\n//;
		    $p =~ s/^\tpushl\s+\%esi\n//;
		    $p =~ s/^\tpushl\s+\%ebx\n//;
		    $p =~ s/^\tsubl\s+\$\d+,\s*\%esp\n//;
                    $p =~ s/^\tmovl\s+\$\d+,\s*\%eax\n\tcall\s+__alloca\n// if ($TargetPlatform =~ /^.*-cygwin32/);
		} elsif ($TargetPlatform =~ /^m68k-/) {
		    $p =~ s/^\tlink a6,#-?\d.*\n//;
 		    $p =~ s/^\tpea a6@\n\tmovel sp,a6\n//;    
 				# The above showed up in the asm code,
 				# so I added it here.
 				# I hope it's correct.
 				# CaS
		    $p =~ s/^\tmovel d2,sp\@-\n//;
		    $p =~ s/^\tmovel d5,sp\@-\n//; # SMmark.* only?
		    $p =~ s/^\tmoveml \#0x[0-9a-f]+,sp\@-\n//; # SMmark.* only?
		} elsif ($TargetPlatform =~ /^mips-/) {
		    # the .frame/.mask/.fmask that we use is the same
		    # as that produced by GCC for miniInterpret; this
		    # gives GDB some chance of figuring out what happened
		    $FRAME = "\t.frame\t\$sp,2168,\$31\n\t.mask\t0x90000000,-4\n\t.fmask\t0x00000000,0\n";
		    $p =~ s/^\t\.(frame).*\n/__FRAME__/g;
		    $p =~ s/^\t\.(mask|fmask).*\n//g;
		    $p =~ s/^\t\.cprestore.*\n/\t\.cprestore 416\n/; # 16 + 100 4-byte args
		    $p =~ s/^\tsubu\t\$sp,\$sp,\d+\n//;
		    $p =~ s/^\tsw\t\$31,\d+\(\$sp\)\n//;
		    $p =~ s/^\tsw\t\$fp,\d+\(\$sp\)\n//;
		    $p =~ s/^\tsw\t\$28,\d+\(\$sp\)\n//;
		    $p =~ s/__FRAME__/$FRAME/;
 		} elsif ($TargetPlatform =~ /^powerpc-|^rs6000/) {
 		    $p =~ s/^\tmflr 0\n//;
 		    $p =~ s/^\tstm \d+,-\d+\(1\)\n//;
  		    $p =~ s/^\tstw? 0,\d+\(1\)\n//g;
  		    $p =~ s/^\tstw? 1,\d+\(1\)\n//g; #mc
  		    $p =~ s/^\tlw?z 0,0\(1\)\n//g;   #mc
  		    $p =~ s/^\tstw?u 1,-\d+\(1\)\n//; 
  		    $p =~ s/^\tstw? \d+,-\d+\(1\)\n//g; 
  		    $p =~ s/^\tstfd \d+,-\d+\(1\)\n//g; 
		} else {
		    print STDERR "$Pgm: unknown prologue mangling? $TargetPlatform\n";
		}

		# HWL HACK: dont die, just print a warning
		#print stderr  "HWL: this should die! Prologue junk?: $p\n" if $p =~ /^\t[^\.]/
		#    && $TargetPlatform !~ /^powerpc-/; #ToDo: remove test
		die "Prologue junk?: $p\n" if $p =~ /^\t[^\.]/
		    && $TargetPlatform !~ /^powerpc-/; #ToDo: remove test

		# glue together what's left
		$c = $p . $r;
		$c =~ s/\n\t\n/\n/; # junk blank line
	    }
	}

	if ( $TargetPlatform =~ /^mips-/ ) {
	    # MIPS: first, this basic sequence may occur "--- END ---" or not
	    $c =~ s/^\tlw\t\$31,\d+\(\$sp\)\n\taddu\t\$sp,\$sp,\d+\n\tj\t\$31\n\t\.end/\t\.end/;
	}

	# toss all epilogue stuff; again, paranoidly
	if ( $c =~ /--- END ---/ ) {
	    if (($r, $e) = split(/--- END ---/, $c)) {
		if ($TargetPlatform =~ /^i386-/) {
		    $e =~ s/^\tret\n//;
		    $e =~ s/^\tpopl\s+\%edi\n//;
		    $e =~ s/^\tpopl\s+\%esi\n//;
		    $e =~ s/^\tpopl\s+\%edx\n//;
		    $e =~ s/^\tpopl\s+\%ecx\n//;
		    $e =~ s/^\taddl\s+\$\d+,\s*\%esp\n//;
		    $e =~ s/^\tsubl\s+\$-\d+,\s*\%esp\n//;
		} elsif ($TargetPlatform =~ /^m68k-/) {
		    $e =~ s/^\tunlk a6\n//;
		    $e =~ s/^\trts\n//;
		} elsif ($TargetPlatform =~ /^mips-/) {
		    $e =~ s/^\tlw\t\$31,\d+\(\$sp\)\n//;
		    $e =~ s/^\tlw\t\$fp,\d+\(\$sp\)\n//;
		    $e =~ s/^\taddu\t\$sp,\$sp,\d+\n//;
		    $e =~ s/^\tj\t\$31\n//;
 		} elsif ($TargetPlatform =~ /^powerpc-|^rs6000-/) {
  		    $e =~ s/^\taddi 1,1,\d+\n//;
  		    $e =~ s/^\tcal 1,\d+\(1\)\n//;
  		    $e =~ s/^\tlw?z? \d+,\d+\(1\)\n//; 
 		    $e =~ s/^\tmtlr 0\n//;
  		    $e =~ s/^\tbl?r\n//;
		} else {
		    print STDERR "$Pgm: unknown epilogue mangling? $TargetPlatform\n";
		}

		print "WARNING: Epilogue junk?: $e\n" if $e =~ /^\t\s*[^\.\s\n]/
		   && $TargetPlatform !~ /^powerpc-/; #ToDo: remove test

		# glue together what's left
		$c = $r . $e;
		$c =~ s/\n\t\n/\n/; # junk blank line
	    }
	}

	# On SPARCs, we don't do --- BEGIN/END ---, we just
	# toss the register-windowing save/restore/ret* instructions
	# directly:
	if ( $TargetPlatform =~ /^sparc-/ ) {
	    $c =~ s/^\t(save.*|restore|ret|retl)\n//g;
	    # throw away PROLOGUE comments
	    $c =~ s/^\t!#PROLOGUE# 0\n\t!#PROLOGUE# 1\n//;
	}

	# On Alphas, the prologue mangling is done a little later (below)

    	# toss all calls to __DISCARD__
	$c =~ s/^\t(call|jbsr|jal)\s+$TUS[@]?__DISCARD__\n//go;

	# MIPS: that may leave some gratuitous asm macros around
	# (no harm done; but we get rid of them to be tidier)
	$c =~ s/^\t\.set\tnoreorder\n\t\.set\tnomacro\n\taddu\t(\S+)\n\t\.set\tmacro\n\t\.set\treorder\n/\taddu\t$1\n/
	    if $TargetPlatform =~ /^mips-/;

    	# toss stack adjustment after DoSparks
    	$c =~ s/^(\tjbsr _DoSparks\n)\taddqw #8,sp/$1/g
		if $TargetPlatform =~ /^m68k-/; # this looks old...

	if ( $TargetPlatform =~ /^alpha-/ &&
	   ! $magic_rdata_seen &&
	   $c =~ /^\s*\.rdata\n\t\.quad 0\n\t\.align \d\n/ ) {
	    $c =~ s/^\s*\.rdata\n\t\.quad 0\n\t\.align (\d)\n/\.rdata\n\t\.align $1\n/;
	    $magic_rdata_seen = 1;
	}

	# pick some end-things and move them to the next chunk

	# pin a funny end-thing on (for easier matching):
	$c .= 'FUNNY#END#THING';

	while ( $c =~ /$TMOVEDIRVS[@]?FUNNY#END#THING/o ) {  # [@]? is a silly hack to avoid having to use curlies for T_PRE_APP
				                           # (this SEGVs perl4 on alphas, you see)

	    $to_move = $1;

	    # on x86 we try not to copy any directives into a literal
	    # chunk, rather we keep looking for the next real chunk.  This
	    # is because we get things like
	    #
	    #    .globl blah_closure
	    #    .LC32
	    #    	.string "..."
	    #    blah_closure:
	    #		...
            #
	    if ( $TargetPlatform =~ /^(i386|sparc)/ && $to_move =~ /$TCOPYDIRVS/ ) {
		$j = $i + 1;
		while ( $j < $numchks  && $chk[$j] =~ /$T_CONST_LBL/) {
			$j++;
		}
		if ( $j < $numchks ) {
			$chk[$j] = $to_move . $chk[$j];
	        }
	    }

	    elsif ( $i < ($numchks - 1)
	      && ( $to_move =~ /$TCOPYDIRVS/
	        || ($TargetPlatform =~ /^hppa/ && $to_move =~ /align/ && $chkcat[$i+1] eq 'literal') )) {
		$chk[$i + 1] = $to_move . $chk[$i + 1];
		# otherwise they're tossed
	    }

	    $c =~ s/$TMOVEDIRVS[@]?FUNNY#END#THING/FUNNY#END#THING/o; # [@]? is a hack (see above)
	}

    	if ( $TargetPlatform =~ /^alpha-/ && $c =~ /^\t\.ent\s+(\S+)/ ) {
    	    $ent = $1;
	    # toss all prologue stuff, except for loading gp, and the ..ng address
	    if (($p, $r) = split(/^\t\.prologue/, $c)) {
    	        if (($keep, $junk) = split(/\.\.ng:/, $p)) {
    	    	    $c = $keep . "..ng:\n";
    	        } else {
    	    	    print STDERR "malformed code block ($ent)?\n"
    	    	}
    	    }
    	    $c .= "\t.frame \$30,0,\$26,0\n\t.prologue" . $r;
    	}
  
	$c =~ s/FUNNY#END#THING//;

#	print STDERR "\nCHK $i (AFTER) (",$chkcat[$i],"):\n", $c;

	$chk[$i] = $c; # update w/ convenience copy
    }

    if ( $TargetPlatform =~ /^alpha-/ ) {
	# print out the header stuff first
	$chk[0] =~ s/^(\t\.file.*)"(ghc\d+\.c)"/$1"$ifile_root.hc"/;
	print OUTASM $chk[0];

    } elsif ( $TargetPlatform =~ /^hppa/ ) {
	print OUTASM $chk[0];

    } elsif ( $TargetPlatform =~ /^mips-/ ) {
	$chk[0] = "\t\.file\t1 \"$ifile_root.hc\"\n" . $chk[0];

	# get rid of horrible "<dollar>Revision: .*$" strings
	local(@lines0) = split(/\n/, $chk[0]);
	local($z) = 0;
	while ( $z <= $#lines0 ) {
	    if ( $lines0[$z] =~ /^\t\.byte\t0x24,0x52,0x65,0x76,0x69,0x73,0x69,0x6f$/ ) {
		undef($lines0[$z]);
		$z++;
		while ( $z <= $#lines0 ) {
		    undef($lines0[$z]);
		    last if $lines0[$z] =~ /[,\t]0x0$/;
		    $z++;
		}
	    }
	    $z++;
	}
	$chk[0] = join("\n", @lines0);
	$chk[0] =~ s/\n\n+/\n/;
	print OUTASM $chk[0];
    }

    # print out all the literal strings next
    for ($i = 0; $i < $numchks; $i++) {
	if ( $chkcat[$i] eq 'literal' ) {
	    print OUTASM $T_HDR_literal, $chk[$i];
	    print OUTASM "; end literal\n" if $TargetPlatform =~ /^hppa/; # for the splitter

	    $chkcat[$i] = 'DONE ALREADY';
	}
    }

    # on the HPPA, print out all the bss next
    if ( $TargetPlatform =~ /^hppa/ ) {
	for ($i = 1; $i < $numchks; $i++) {
	    if ( $chkcat[$i] eq 'bss' ) {
		print OUTASM "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$BSS\$\n\t.align 4\n";
		print OUTASM $chk[$i];

		$chkcat[$i] = 'DONE ALREADY';
	    }
	}
    }

    for ($i = $FIRST_MANGLABLE; $i < $numchks; $i++) {
#	print STDERR "$i: cat $chkcat[$i], symb $chksymb[$i]\n";

	next if $chkcat[$i] eq 'DONE ALREADY';

	if ( $chkcat[$i] eq 'misc' ) {
	    if ($chk[$i] ne '') {
		print OUTASM $T_HDR_misc;
                if ($TargetPlatform =~ /^powerpc-|^rs6000/) { 
                   $chksymb[$i] =~ s/://;
#new                   if ($chksymb[$i] =~ /ret.*upd/ || $KNOWN_FUNNY_THING{$chksymb[$i]}
#new                    || $chksymb[$i] =~ /^$.{T_US}_(PRIn|PRStart).*${T_POST_LBL}$/o )
#new                      { print OUTASM "\t\.globl $chksymb[$i]\n"; }
#                   if ($chksymb[$i] ne '' && $chksymb[$i] !~ /ret_[a-z]/ && $chksymb[$i] !~ /djn_[a-z]/) 
                   if ($chksymb[$i] ne '')
                       { print OUTASM "\t\.globl \.$chksymb[$i]\n"; };
                   if ($chk[$i] =~ /TOC\[tc0\], 0\n/)
	             { ($p, $r) = split(/TOC\[tc0\], 0\n/, $chk[$i]); $printDS = 1;}
                   else { $r = $chk[$i]; $printDS = 0; };
                   $chk[$i] = &mangle_powerpc_tailjump($r);
                };
 		&print_doctored($chk[$i], 0);
                if ($TargetPlatform =~ /^powerpc-|^rs6000-/ && $printDS) { 
#ok                   if ($chksymb[$i] !~ /\__init_Main/) {
  		     print OUTASM "\.csect ${chksymb[$i]}[DS]\n"; 	
  		     print OUTASM "${p}TOC[tc0], 0\n";
#ok                   }
                }
	    }

	} elsif ( $chkcat[$i] eq 'toss' ) {
	    print STDERR "*** NB: TOSSING code for $chksymb[$i] !!! ***\n";

	} elsif ( $chkcat[$i] eq 'data' ) {
	    if ($chk[$i] ne '') {
		print OUTASM $T_HDR_data;
		print OUTASM $chk[$i];
	    }

	} elsif ( $chkcat[$i] eq 'consist' ) {
	    if ( $chk[$i] =~ /$T_hsc_cc_PAT/o ) {
		local($consist) = "$1.$2.$3";
		$consist =~ s/,/./g;
		$consist =~ s/\//./g;
		$consist =~ s/-/_/g;
		$consist =~ s/[^A-Za-z0-9_.]/ZZ/g; # ToDo: properly?
		#
		# Using a cygnus-2.7-96q4 gcc build on hppas, the 
		# consistency chunk for ghc_cc_ID often (but not always!)
		# gets lumped with a bunch of .IMPORT directives containing info on
		# the code or data space nature of external symbols. We can't
		# toss these, so once the consistency ID has been turned into
		# a representable symbol, we substitute it for the symbol
		# that the string was attached to in the first place (ghc_cc_ID.)
		# (The original string is also substituted away.)
		#
		# This change may affect the code output on other platforms in
		# adverse ways, hence we restrict this hack hppa targets only.
		#
		#    -- 2/98 SOF
		if ( $TargetPlatform =~ /^hppa/ )  {
			$chk[$i] =~ s/^$TUS[@]?ghc.*c_ID$TPOSTLBL/$consist/o;
			$chk[$i] =~ s/\t$T_hsc_cc_PAT/$T_HDR_misc/o;
			$consist = $chk[$i]; #clumsily
                }
		print OUTASM $T_HDR_consist, "${consist}${T_POST_LBL}\n";

	    } elsif ( $TargetPlatform !~ /^(mips)-/ ) { # we just don't try in those case (ToDo)
		# on mips: consistency string is just a v
		# horrible bunch of .bytes,
		# which I am too lazy to sort out (WDP 95/05)

		print STDERR "Couldn't grok consistency: ", $chk[$i];
	    }

	} elsif ( $chkcat[$i] eq 'splitmarker' ) {
	    # we can just re-constitute this one...
	    # NB: we emit _three_ underscores no matter what,
	    # so ghc-split doesn't have to care.
	    print OUTASM "___stg_split_marker",$chksymb[$i],"${T_POST_LBL}\n";

	} elsif ( $chkcat[$i] eq 'closure'
	       || $chkcat[$i] eq 'srt'
	       || $chkcat[$i] eq 'infotbl'
	       || $chkcat[$i] eq 'slow'
	       || $chkcat[$i] eq 'fast' ) { # do them in that order
	    $symb = $chksymb[$i];

	    # CLOSURE
	    if ( defined($closurechk{$symb}) ) {
		print OUTASM $T_HDR_closure;
		print OUTASM $chk[$closurechk{$symb}];
		$chkcat[$closurechk{$symb}] = 'DONE ALREADY';
	    }

	    # SRT
	    if ( defined($srtchk{$symb}) ) {
		print OUTASM $T_HDR_srt;
		print OUTASM $chk[$srtchk{$symb}];
		$chkcat[$srtchk{$symb}] = 'DONE ALREADY';
	    }

	    # INFO TABLE
	    if ( defined($infochk{$symb}) ) {

		print OUTASM $T_HDR_info;
                if ($TargetPlatform =~ /^powerpc-|^rs6000-/) {
	          if ( !defined($slowchk{$symb}) && defined($fastchk{$symb}) ) {
 		     $fastname = $chk[$fastchk{$symb}];
 		     $fastname =~ s/([_A-Za-z]*_fast\d+):.*(.*\n)*/\1/;
                     $chk[$infochk{$symb}] =~ s/\.long StdErrorCode/\.long $fastname/;
                  }
                  $chk[$infochk{$symb}] =~ s/\.long ([_A-Za-z]\S+_entry)/\.long \.\1/;
                  $chk[$infochk{$symb}] =~ s/\.long ([A-Za-z]\S+_upd)/\.long \.\1/;
                  print OUTASM $chk[$infochk{$symb}];
                } else {
		  print OUTASM &rev_tbl($symb, $chk[$infochk{$symb}], 1);
                }
		# entry code will be put here!

		$chkcat[$infochk{$symb}] = 'DONE ALREADY';
	    }

	    # STD ENTRY POINT
	    if ( defined($slowchk{$symb}) ) {

		# teach it to drop through to the fast entry point:
		$c = $chk[$slowchk{$symb}];

                if ($TargetPlatform =~ /^powerpc-|^rs6000-/) { 
	          ($p, $r) = split(/TOC\[tc0\], 0\n/, $c); 
                  if ($symb =~ /^[_A-Z]/)
		  { 
		    print OUTASM "\t\.globl \.${chksymb[$i]}_entry\n"; 
		    print OUTASM "\.csect ${symb}_entry[DS]\n"; 	
		    print OUTASM "${p}TOC[tc0], 0\n";
                  }; 
                  $r =~ s/\.csect \.text\[PR\]\n//; # todo: properly - andre
                  $c = &mangle_powerpc_tailjump($r);
                };

		if ( defined($fastchk{$symb}) ) {
		    if ( $TargetPlatform =~ /^alpha-/ ) {
			$c =~ s/^\tjmp \$31,\(\$27\),0\n\t\.align 4\n\t\.end/\t.align 4\n\t.end/;
		    } elsif ( $TargetPlatform =~ /^hppa/ ) {
			$c =~ s/^\s+ldil.*\n\s+ldo.*\n\s+bv.*\n(.*\n)?\s+\.EXIT/$1\t.EXIT/;
		    } elsif ( $TargetPlatform =~ /^i386-/ ) {
			# Reg alloc depending, gcc generated code may jump to the fast entry point via
			# a number of registers.
			$c =~ s/^\tmovl\s+\$${T_US}${symb}_fast\d*,\s*\%edx\n\tjmp\s+\*\%edx\n//;
			$c =~ s/^\tmovl\s+\$${T_US}${symb}_fast\d*,\s*\%ecx\n\tjmp\s+\*\%ecx\n//;
			$c =~ s/^\tmovl\s+\$${T_US}${symb}_fast\d*,\s*\%eax\n\tjmp\s+\*\%eax\n//;
			# The next two only apply if we're not stealing %esi or %edi.
			$c =~ s/^\tmovl\s+\$${T_US}${symb}_fast\d*,\s*\%esi\n\tjmp\s+\*\%esi\n// if ($StolenX86Regs < 3);
			$c =~ s/^\tmovl\s+\$${T_US}${symb}_fast\d*,\s*\%edi\n\tjmp\s+\*\%edi\n// if ($StolenX86Regs < 4);
		    } elsif ( $TargetPlatform =~ /^mips-/ ) {
			$c =~ s/^\tjmp \$31,\(\$27\),0\n\t\.align 4\n\t\.end/\t.align 4\n\t.end/;
		    } elsif ( $TargetPlatform =~ /^m68k-/ ) {
			$c =~ s/^\tjmp ${T_US}${symb}_fast\d+.*\n\tnop\n//;
			$c =~ s/^\tjmp ${T_US}${symb}_fast\d+.*\n//;
		    } elsif ( $TargetPlatform =~ /^powerpc-|^rs6000-/ ) {
			$c =~ s/^\tb \.${T_US}${symb}_fast\d+\n//;
		    } elsif ( $TargetPlatform =~ /^sparc-/ ) {
			$c =~ s/^\tcall\s+${T_US}${symb}_fast\d+,.*\n\t\s*nop\n//;
			$c =~ s/^\tcall\s+${T_US}${symb}_fast\d+,.*\n(\t\s*[a-z].*\n)/$1/;
		    } else {
			print STDERR "$Pgm: mystery slow-fast dropthrough: $TargetPlatform\n";
		    }
		}

		if ( $TargetPlatform !~ /^(alpha-|hppa|mips-)/ ) {
		    # On alphas, hppa: no very good way to look for "dangling"
		    # references to fast-entry point.
		    # (questionable re hppa and mips...)
		    print STDERR "still has jump to fast entry point:\n$c"
			if $c =~ /$TUS[@]?$symb[@]?_fast/; # NB: paranoia
		}

		print OUTASM $T_HDR_entry;

		&print_doctored($c, 1); # NB: the 1!!!

		$chkcat[$slowchk{$symb}] = 'DONE ALREADY';
	    }
	    
	    # FAST ENTRY POINT
	    if ( defined($fastchk{$symb}) ) {
 		$c = $chk[$fastchk{$symb}];
    	    	if ( ! defined($slowchk{$symb})
		   # ToDo: the || clause can go once we're no longer
		   # concerned about producing exactly the same output as before
#OLD:		   || $TargetPlatform =~ /^(m68k|sparc|i386)-/
		   ) {
		    print OUTASM $T_HDR_fast;
		}
                  if ($TargetPlatform =~ /^powerpc-|^rs6000-/) {
                    local(@lbls) = split(/:/, $c);
                    $fullname = $lbls[0];
 	            $fullname =~ s/$T_MOVE_DIRVS//g;
                    if ( $fullname =~ /^[A-Z]/)
                       { print OUTASM "\t\.globl \.${fullname}\n";
                    } else {
#                       print OUTASM "\t\.lglobl \.${fullname}\n"; #todo: rm - andre
                    };
                    $c =~ s/((.*\n)*)\t.long \S+, TOC\[tc0\], 0\n\.csect \.text\[PR\]\n((.*\n)*)/\1\3/;
                    $c = &mangle_powerpc_tailjump($c);
                  };
 		&print_doctored($c, 0);
		$chkcat[$fastchk{$symb}] = 'DONE ALREADY';
	    }

	} elsif ( $chkcat[$i] eq 'vector'
	       || $chkcat[$i] eq 'direct' ) { # do them in that order
	    $symb = $chksymb[$i];

	    # VECTOR TABLE
	    if ( defined($vectorchk{$symb}) ) {
		print OUTASM $T_HDR_vector;
                if ($TargetPlatform =~ /^powerpc-|^rs6000-/) { 
                  if ( $symb =~ /^[A-Z]/) {
                     print OUTASM "\t\.globl \.${symb}_vtbl\n";
		     print OUTASM "\t\.globl ${symb}_vtbl\n";
                  };
		  $chk[$vectorchk{$symb}] =~ s/\.long (\S+)/\.long \.\1/g;
		  print OUTASM ".${symb}_vtbl:\n";
		  print OUTASM $chk[$vectorchk{$symb}];
		} else {
  		  print OUTASM &rev_tbl($symb, $chk[$vectorchk{$symb}], 0);
		}
		# direct return code will be put here!
		$chkcat[$vectorchk{$symb}] = 'DONE ALREADY';

	    } elsif ( $TargetPlatform =~ /^alpha-/ ) {
		# Alphas: the commented nop is for the splitter, to ensure
		# that no module ends with a label as the very last
		# thing.  (The linker will adjust the label to point
		# to the first code word of the next module linked in,
		# even if alignment constraints cause the label to move!)

		print OUTASM "\t# nop\n";
	    }
	    
 	} elsif ( $chkcat[$i] eq 'toc' ) {
            # silly optimisation to print tocs, since they come in groups...
 	    print OUTASM $T_HDR_toc;
            local($j)	= $i;
            while ($chkcat[$j] eq 'toc')
              { if (   $chk[$j] !~ /\.tc UpdatePAP\[TC\]/ # not needed: always turned into a jump.
                   ) 
                {
                  print OUTASM $chk[$j];
                }
                $chkcat[$j] = 'DONE ALREADY';
                $j++;
 	    }
 	    
	} else {
	    &tidy_up_and_die(1,"$Pgm: unknown chkcat (ghc-asm: $TargetPlatform)\n$chkcat[$i]\n$chk[$i]\n");
	}
    }

    print OUTASM $EXTERN_DECLS if $TargetPlatform =~ /^mips-/;

    if ($TargetPlatform =~ /^powerpc-|^rs6000-/) { 
         print OUTASM ".csect .text[PR]\n_section_.text:\n.csect .data[RW]\n\t.long _section_.text\n"
    };

    # finished
    close(OUTASM) || &tidy_up_and_die(1,"Failed writing to $out_asmf\n");
    close(INASM)  || &tidy_up_and_die(1,"Failed reading from $in_asmf\n");
}
\end{code}

\begin{code}
sub mash_hppa_prologue { # OK, epilogue, too
    local($_) = @_;

    # toss all prologue stuff
    s/^\s+\.ENTRY[^\0]*--- BEGIN ---/\t.ENTRY/;

    # Lie about our .CALLINFO
    s/^\s+\.CALLINFO.*$/\t.CALLINFO NO_CALLS,NO_UNWIND/;

    # Get rid of P'

    s/LP'/L'/g;
    s/RP'/R'/g;

    # toss all epilogue stuff
    s/^\s+--- END ---[^\0]*\.EXIT/\t.EXIT/;

    # Sorry; we moved the _info stuff to the code segment.
    s/_info,DATA/_info,CODE/g;

    return($_);
}
\end{code}

\begin{code}
sub print_doctored {
    local($_, $need_fallthru_patch) = @_;

    if ( $TargetPlatform !~ /^i386-/ 
      || ! /^\t[a-z]/  # no instructions in here, apparently
      || /^${T_US}__init_[A-Za-z0-9_]+${T_POST_LBL}/) {
	print OUTASM $_;
	return;
    }
    # OK, must do some x86 **HACKING**

    local($entry_patch)	= '';
    local($exit_patch)	= '';

    # gotta watch out for weird instructions that
    # invisibly smash various regs:
    #   rep*	%ecx used for counting
    #   scas*	%edi used for destination index
    #   cmps*	%e[sd]i used for indices
    #   loop*	%ecx used for counting
    #
    # SIGH.

    # We cater for:
    #  * use of STG reg [ nn(%ebx) ] where no machine reg avail
    #
    #  * GCC used an "STG reg" for its own purposes
    #
    #  * some secret uses of machine reg, requiring STG reg
    #    to be saved/restored

    # The most dangerous "GCC uses" of an "STG reg" are when
    # the reg holds the target of a jmp -- it's tricky to
    # insert the patch-up code before we get to the target!
    # So here we change the jmps:

    # --------------------------------------------------------
    # it can happen that we have jumps of the form...
    #   jmp *<something involving %esp>
    # or
    #   jmp <something involving another naughty register...>
    #
    # a reasonably-common case is:
    #
    #   movl $_blah,<bad-reg>
    #   jmp  *<bad-reg>
    #

    s/^\tmovl\s+\$${T_US}(.*),\s*\%eax\n\tjmp\s+\*\%eax/\tjmp $T_US$1/g;
    s/^\tmovl\s+\$${T_US}(.*),\s*\%ebx\n\tjmp\s+\*\%ebx/\tjmp $T_US$1/g;
    s/^\tmovl\s+\$${T_US}(.*),\s*\%ecx\n\tjmp\s+\*\%ecx/\tjmp $T_US$1/g;
    s/^\tmovl\s+\$${T_US}(.*),\s*\%edx\n\tjmp\s+\*\%edx/\tjmp $T_US$1/g;

    if ($StolenX86Regs <= 2 ) { # YURGH! spurious uses of esi?
	s/^\tmovl\s+(.*),\s*\%esi\n\tjmp\s+\*%esi\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*(-?\d*)\((.*\%esi.*)\)\n/\tmovl $2,\%eax\n\tjmp \*$1\(\%eax\)\n/g;
	s/^\tjmp\s+\*\%esi\n/\tmovl \%esi,\%eax\n\tjmp \*\%eax\n/g;
	die "$Pgm: (mangler) still have jump involving \%esi!\n$_"
	    if /(jmp|call)\s+.*\%esi/;
    }
    if ($StolenX86Regs <= 3 ) { # spurious uses of edi?
	s/^\tmovl\s+(.*),\s*\%edi\n\tjmp\s+\*%edi\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*(-?\d*\(.*\%edi.*\))\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*\%edi\n/\tmovl \%edi,\%eax\n\tjmp \*\%eax\n/g;
	die "$Pgm: (mangler) still have jump involving \%edi!\n$_"
	    if /(jmp|call)\s+.*\%edi/;
    }

    # OK, now we can decide what our patch-up code is going to
    # be:

    # Offsets into register table - you'd better update these magic
    # numbers should you change its contents!
    # local($OFFSET_R1)=0;  No offset for R1 in new RTS.
    local($OFFSET_Hp)=92;

	# Note funky ".=" stuff; we're *adding* to these _patch guys
    if ( $StolenX86Regs <= 2
	 && ( /[^0-9]\(\%ebx\)/ || /\%esi/ || /^\tcmps/ ) ) { # R1 (esi)
	$entry_patch .= "\tmovl \%esi,(\%ebx)\n";
	$exit_patch  .= "\tmovl (\%ebx),\%esi\n";

	# nothing for call_{entry,exit} because %esi is callee-save
    }
    if ( $StolenX86Regs <= 3
	 && ( /${OFFSET_Hp}\(\%ebx\)/ || /\%edi/ || /^\t(scas|cmps)/ ) ) { # Hp (edi)
	$entry_patch .= "\tmovl \%edi,${OFFSET_Hp}(\%ebx)\n";
	$exit_patch  .= "\tmovl ${OFFSET_Hp}(\%ebx),\%edi\n";

	# nothing for call_{entry,exit} because %edi is callee-save
    }

    # --------------------------------------------------------
    # next, here we go with non-%esp patching!
    #
    s/^(\t[a-z])/$entry_patch$1/; # before first instruction

# Before calling GC we must set up the exit condition before the call
# and entry condition when we come back

    # fix _all_ non-local jumps:

    s/^\tjmp\s+\*${T_X86_PRE_LLBL_PAT}/\tJMP___SL/go;
    s/^\tjmp\s+${T_X86_PRE_LLBL_PAT}/\tJMP___L/go;

    s/^(\tjmp\s+.*\n)/$exit_patch$1/g; # here's the fix...

    s/^\tJMP___SL/\tjmp \*${T_X86_PRE_LLBL}/go;
    s/^\tJMP___L/\tjmp ${T_X86_PRE_LLBL}/go;

    if ($StolenX86Regs == 2 ) {
	die "ARGH! Jump uses \%esi or \%edi with -monly-2-regs:\n$_" 
	    if /^\t(jmp|call)\s+.*\%e(si|di)/;
    } elsif ($StolenX86Regs == 3 ) {
	die "ARGH! Jump uses \%edi with -monly-3-regs:\n$_" 
	    if /^\t(jmp|call)\s+.*\%edi/;
    }

    # --------------------------------------------------------
    # that's it -- print it
    #
    #die "Funny jumps?\n$_" if /${T_X86_BADJMP}/o; # paranoia

    print OUTASM $_;

    if ( $need_fallthru_patch ) { # exit patch for end of slow entry code
	print OUTASM $exit_patch;
	# ToDo: make it not print if there is a "jmp" at the end
    }
}
\end{code}

\begin{code}
sub init_FUNNY_THINGS {
    %KNOWN_FUNNY_THING = (
	# example
	# "${T_US}stg_.*{T_POST_LBL}", 1,  
    );
}
\end{code}

The following table reversal is used for both info tables and return
vectors.  In both cases, we remove the first entry from the table,
reverse the table, put the label at the end, and paste some code
(that which is normally referred to by the first entry in the table)
right after the table itself.  (The code pasting is done elsewhere.)

\begin{code}
sub rev_tbl {
    local($symb, $tbl, $discard1) = @_;

    local($before) = '';
    local($label) = '';
    local(@imports) = (); # hppa only
    local(@words) = ();
    local($after) = '';
    local(@lines) = split(/\n/, $tbl);
    local($i, $j); #local ($i, $extra, $words_to_pad, $j);

    # see comment in mangleAsm as to why this silliness is needed.
    local($TDOTWORD) = ${T_DOT_WORD};
    local($TDOTGLOBAL) = ${T_DOT_GLOBAL};
    local($TUS) = ${T_US};
    local($TPOSTLBL) = ${T_POST_LBL};

    # Deal with the header...
    for ($i = 0; $i <= $#lines && $lines[$i] !~ /^\t?$TDOTWORD\s+/o; $i++) {
	$label .= $lines[$i] . "\n",
	    next if $lines[$i] =~ /^[A-Za-z0-9_]+_info$TPOSTLBL[@]?$/o
		 || $lines[$i] =~ /$TDOTGLOBAL/o
		 || $lines[$i] =~ /^$TUS[@]?\S+_vtbl$TPOSTLBL[@]?$/o;

	$before .= $lines[$i] . "\n"; # otherwise...
    }

    # Grab the table data...
    if ( $TargetPlatform !~ /^hppa/ ) {
	for ( ; $i <= $#lines && $lines[$i] =~ /^\t?$TDOTWORD\s+/o; $i++) {
	    push(@words, $lines[$i]);
	}
    } else { # hppa weirdness
	for ( ; $i <= $#lines && $lines[$i] =~ /^\s+($TDOTWORD|\.IMPORT)/; $i++) {
	    if ($lines[$i] =~ /^\s+\.IMPORT/) {
		push(@imports, $lines[$i]);
	    } else {
		# We don't use HP's ``function pointers''
		# We just use labels in code space, like normal people
		$lines[$i] =~ s/P%//;
		push(@words, $lines[$i]);
	    }
	}
    }

    # now throw away the first word (SRT) iff it is empty.
    # The .zero business is for Linux/ELF.
    # The .skip business is for Sparc/Solaris/ELF.
    # The .blockz business is for HPPA.
    if ($discard1 && $words[0] =~ /^\t?($TDOTWORD\s+0|\.zero\s+4|\.skip\s+4|\.blockz\s+4)/) {
	shift(@words)
    }

# Padding removed to reduce code size and improve performance on Pentiums.
# Simon M. 13/4/96
    # for 486-cache-friendliness, we want our tables aligned
    # on 16-byte boundaries (.align 4).  Let's pad:
#    $extra = ($#words + 1) % 4;
#    $words_to_pad = ($extra == 0) ? 0 : 4 - $extra;
#    for ($j = 0; $j < $words_to_pad; $j++) { push(@words, "\t${T_DOT_WORD} 0"); }

    for (; $i <= $#lines; $i++) {
	$after .= $lines[$i] . "\n";
    }

    # Alphas:If we have anonymous text (not part of a procedure), the
    # linker may complain about missing exception information.  Bleh.
    if ( $TargetPlatform =~ /^alpha-/ && $label =~ /^([A-Za-z0-9_]+):$/) {
    	$before = "\t.ent $1\n" . $before;
    	$after .= "\t.end $1\n";
    }

    $tbl = $before
	 . (($TargetPlatform !~ /^hppa/) ? '' : join("\n", @imports) . "\n")
	 . join("\n", @words) . "\n"
	 . $label . $after;

#   print STDERR "before=$before\n";
#   print STDERR "label=$label\n";
#   print STDERR "words=",(reverse @words),"\n";
#   print STDERR "after=$after\n";

    $tbl;
}
\end{code}

The HP is a major nuisance.  The threaded code mangler moved info
tables from data space to code space, but unthreaded code in the RTS
still has references to info tables in data space.  Since the HP
linker is very precise about where symbols live, we need to patch the
references in the unthreaded RTS as well.

\begin{code}
sub mini_mangle_asm_hppa {
    local($in_asmf, $out_asmf) = @_;

    open(INASM, "< $in_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$in_asmf' (to read)\n");
    open(OUTASM,"> $out_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$out_asmf' (to write)\n");

    while (<INASM>) {
	s/_info,DATA/_info,CODE/;   # Move _info references to code space
	s/P%_PR/_PR/;
	print OUTASM;
    }

    # finished:
    close(OUTASM) || &tidy_up_and_die(1,"Failed writing to $out_asmf\n");
    close(INASM)  || &tidy_up_and_die(1,"Failed reading from $in_asmf\n");
}

\end{code}
 
\begin{code}
sub mini_mangle_asm_powerpc {
    local($in_asmf, $out_asmf) = @_;

    open(INASM, "< $in_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$in_asmf' (to read)\n");
    open(OUTASM,"> $out_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$out_asmf' (to write)\n");

    while (<INASM>) {
	s/long _PRStart/long ._PRStart/;
	s/long _PRIn_/long ._PRIn_/;
	s/long _Dummy_(\S+)_entry/long ._Dummy_\1_entry/;
	s/long _PRMarking_MarkNextRoot\[DS\]/long ._PRMarking_MarkNextRoot/;
	s/long _PRMarking_MarkNextCAF\[DS\]/long ._PRMarking_MarkNextCAF/;
	s/long _PRMarking_MarkNextAStack\[DS\]/long ._PRMarking_MarkNextAStack/;
	s/long _PRMarking_MarkNextBStack\[DS\]/long ._PRMarking_MarkNextBStack/;
        s/\.tc EnterNodeCode\[TC]\,EnterNodeCode\[DS\]/\.tc EnterNodeCode\[TC]\,.EnterNodeCode/; # CONC
        s/\.tc CheckHeapCode\[TC]\,CheckHeapCode\[DS\]/\.tc CheckHeapCode\[TC]\,.CheckHeapCode/; # CONC
	print OUTASM;
    }

    # finished:
    close(OUTASM) || &tidy_up_and_die(1,"Failed writing to $out_asmf\n");
    close(INASM)  || &tidy_up_and_die(1,"Failed reading from $in_asmf\n");
}

sub mangle_powerpc_tailjump {
    local($c) = @_;
    local($maybe_more) = 1;
    while (($c =~ /\tlw?z? \d+,LC\.\.\d+\(2\)\n\tmtctr \d+\n\tbctr\n/) && $maybe_more) 
      { $maybe_more = 0;
        $lcsymb = $c;
        $lcsymb =~ s/(.*\n)*\tlw?z? \d+,LC\.\.(\d+)\(2\)\n\tmtctr \d+\n\tbctr\n(.*\n)*/\2/;
# the checks for r1 and r2 are mostly paranoia...
        $r1 = $c;
        $r1 =~ s/(.*\n)*\tlw?z? (\d+),LC\.\.\d+\(2\)\n\tmtctr \d+\n\tbctr\n(.*\n)*/\2/;
        $r2 = $c;
        $r2 =~ s/(.*\n)*\tlw?z? \d+,LC\.\.(\d+)\(2\)\n\tmtctr (\d+)\n\tbctr\n(.*\n)*/\3/;
        if (r1 == r2)
          { $maybe_more = 1;
            $c =~ s/((.*\n)*)\tlw?z? \d+,LC\.\.\d+\(2\)\n\tmtctr \d+\n\tbctr\n((.*\n)*)/\1\tb $tocequiv{$lcsymb}\n\3/;
          }
      };
    $c;
}

# make "require"r happy...
1;
\end{code}
